
policies:
  #always one abac-set. one politician or several
  #always abac-combining-algorithm: deny-unless-permit
  policy1:
    target: # target is only a politician, the rules do not
      operation: or #one level of the union or | and
      conditions: # combination of nested AnyOf and AllOf
      - action-id == CourseUnit.Edit #only equal function depends on argument type
      - action-id == CourseUnit.Delete
    rules:
      #Always combining-algorithm: deny-unless-permit
      rule1:
        #always permit  effect: permit
        # by default, do not specify negation: false
        operation: and # wrapped in urn: oasis: names: tc: xacml: 1.0: function: or or in and, NOR and NAND
        conditions:  #- we wrap each line Apply
        - object.CourseUnit.authorId in user.personId # if the attribute is not an array wrapped in one-and-only
        - not object.CourseUnit.status == 'DRAFT' #not wraps the rule in urn: oasis: names: tc: xacml: 1.0: function: not
      rule2:
        # always permit  effect: permit
        negation: true  #not wraps all rules in urn: oasis: names: tc: xacml: 1.0: function: not
        operation: and
        conditions:
        - object.CourseUnit.curatorId == user.personId
        - object.CourseUnit.status == ['DRAFT', 'TEST'] #wrapped in string-bag
        - object.CourseUnit.count > 15  #the type of the simple argument is determined by the type of the left one.
        # the left argument is always an attribute. right or attribute or constant or array of constants
        # attribute types: string, integer, boolean, date, time, datetime
        # functions: string: equal, contains, regex-match, is-in
        #          # integer, date, time, datetime: equal, greater-than, less-than, greater-than-or-equal, less-than-or-equal, is-in
        #          logical: equal
        #          array string, integer, date, time, datetime: set-equal, subset, at-least-one-member-of